#!/usr/bin/env Rscript

# UNNAMED is a classifier of outlier sequences in multiple alignments
# Copyright (C) 2011  Aleksandr Levchuk
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Name of this script
script_path <- sub("--file=","", commandArgs()[grep("--file=", commandArgs())])
script_path_list <- strsplit(script_path, '/')[[1]]
script_name <- script_path_list[[length(script_path_list)]]

# Directory where this script is located
script_dir_list  <- script_path_list[1:(length(script_path_list)-1)]
script_dir  <- paste(script_dir_list, sep='/', collapse="/")

# Guidance build-in SEQ_RES_PAIR score
GUIDANCE_ROCR <- paste(script_dir, "trial-cdd-2011-08-v2.31-uniprot-2011-08",
"070-build-roc-classifer-data-out/predictions1.Rdata", sep="/")

# NorMD modified change ratio variant
NORMD_ROCR <- paste(script_dir, "trial-cdd-2011-08-v2.31-uniprot-2011-08",
"070-build-roc-classifer-data-out/predictions5.Rdata", sep="/")

# How to use this script
usage_and_quit <- function() {
  cat(paste(script_name, "is a utility for MSA alignment cleanup", "\n\n"))
  cat(paste("Usage:", script_name, "<method> <e-mode> <in-msa>", "\n\n"))
  cat(paste(
    "Required Arguments",
    "  <method>  Scoring method. Must be: \"guidance\" or \"normd\"",
    "  <e-mode>  Expected true keeps and removals.",
    "            Must be: \"keep.95tpr\" or \"remove.95tnr\"",
    "  <in-msa>  Input multiple sequence alignment in FASTA format.",
    "",
    sep="\n"))
  quit()
}

# Check number of arguments
script_args <- commandArgs(trailingOnly=T)
if(length(script_args) == 0) usage_and_quit()
if(length(script_args) != 3) {
  cat("ERROR: Invalid number of arguments", length(script_args), "\n")
  usage_and_quit()
}

# Get arguments
scoring_method  <- script_args[[1]]
mode <- script_args[[2]]
msa_fasta <- script_args[[3]]

# Check arguments
if (scoring_method != "guidance" && scoring_method != "normd") {
  cat("ERROR: Method must be \"guidance\" or \"normd\", got \"",
    scoring_method, "\"\n\n", sep="")
  usage_and_quit()
}
if (mode != "keep.95tpr" && mode != "remove.95tnr") {
  cat("ERROR: Method must be \"keep.95tp\" or \"remove.95tn\", got \"",
    mode, "\"\n\n", sep="")
  usage_and_quit()
}

# Load the ROCR object which contains previous data analysis
library(ROCR)
if (scoring_method == "guidance") {
  load(GUIDANCE_ROCR)
  ROCR_PRED <- p_1
} else if (scoring_method == "normd") {
  load(NORMD_ROCR)
  ROCR_PRED <- p_5
}


#str(ROCR_PRED)
#..@ predictions:List of 1
#.. ..$ : num [1:6526] -0.000168 -0.000446 -0.000681 -0.000845 -0.001419 ...
#..@ labels     :List of 1
#.. ..$ : Ord.factor w/ 2 levels "0"<"1": 2 2 2 2 2 2 2 1 1 1 ...
#..@ cutoffs    :List of 1
#.. ..$ : num [1:3565] Inf 0.01239 0.01057 0.01032 0.00988 ...
#..@ fp         :List of 1
#.. ..$ : num [1:3565] 0 0 0 0 0 0 0 0 0 0 ...
#..@ tp         :List of 1
#.. ..$ : num [1:3565] 0 1 2 3 4 5 6 7 8 9 ...
#..@ tn         :List of 1
#.. ..$ : num [1:3565] 285 285 285 285 285 285 285 285 285 285 ...
#..@ fn         :List of 1
#.. ..$ : num [1:3565] 6241 6240 6239 6238 6237 ...
#..@ n.pos      :List of 1
#.. ..$ : int 6241
#..@ n.neg      :List of 1
#.. ..$ : int 285
#..@ n.pos.pred :List of 1
#.. ..$ : num [1:3565] 0 1 2 3 4 5 6 7 8 9 ...
#..@ n.neg.pred :List of 1


# True Positive Rate / False Positive Rate
tpr <- performance(ROCR_PRED, 'tpr')
fpr <- performance(ROCR_PRED, 'fpr')
# Formal class 'performance' [package "ROCR"] with 6 slots
#   ..@ x.name      : chr "Cutoff"
#   ..@ y.name      : chr "True positive rate"
#   ..@ alpha.name  : chr "none"
#   ..@ x.values    :List of 1
#   .. ..$ : num [1:3565] Inf 0.01239 0.01057 0.01032 0.00988 ...
#   ..@ y.values    :List of 1
#   .. ..$ : num [1:3565] 0 0.00016 0.00032 0.000481 0.000641 ...
#   ..@ alpha.values: list()
# Formal class 'performance' [package "ROCR"] with 6 slots
#   ..@ x.name      : chr "Cutoff"
#   ..@ y.name      : chr "False positive rate"
#   ..@ alpha.name  : chr "none"
#   ..@ x.values    :List of 1
#   .. ..$ : num [1:3565] Inf 0.01239 0.01057 0.01032 0.00988 ...
#   ..@ y.values    :List of 1
#   .. ..$ : num [1:3565] 0 0 0 0 0 0 0 0 0 0 ...
#   ..@ alpha.values: list()


# Pick the desired cutoff
tpr_cutoffs <- tpr@x.values[[1]]
tpr_values <- tpr@y.values[[1]]
fpr_cutoffs <- fpr@x.values[[1]]
fpr_values <- fpr@y.values[[1]]
if (paste(tpr_cutoffs, collapse="") != paste(fpr_cutoffs, collapse="")) {
  cat("ERROR: Assertion that tpr_cutoffs == fpr_cutoffs failed!")
  quit()
}

if (mode == "keep.95tpr") {
  offsets <- tpr_values - .95 # Note: they remain sorted

  # Implies that I'm looking for the first value greater than .95
  CUTOFF_LOCATION <- which(offsets > 0)[[1]]
}
if (mode == "remove.95tnr") {
  # TNR = Specificity = 1 - FPR
  tnr_values <- 1 - fpr_values
  offsets <- tnr_values - .95

  # Implies that I'm looking for the first value less than .95
  positive_offsets <- which(offsets > 0)
  CUTOFF_LOCATION <- positive_offsets[length(positive_offsets)]
}

TPR <<- tpr_values[[CUTOFF_LOCATION]]
FPR <<- fpr_values[[CUTOFF_LOCATION]]
CUTOFF <<- tpr_cutoffs[[CUTOFF_LOCATION]]


cat("TPR = True positive rate = Sensitivity = Kept seqs / Related seqs\n")
cat("TNR = True negative rate = Specificity = Removed seqs / Unrelated seqs\n")
cat("FPR = False positive rate = 1 - Specificity\n")
cat("FNR = False negative rate = 1 - Sensitivity\n")
cat("Expected TPR:\t", TPR, "\n", sep="")
cat("Expected TNR:\t", 1 - FPR, "\n", sep="")
cat("Expected FPR:\t", FPR, "\n", sep="")
cat("Expected FNR:\t", 1 - TPR, "\n", sep="")
cat("MSA score cutoff:\t", CUTOFF, "\n", sep="")
