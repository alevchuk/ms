#!/bin/bash

# UNNAMED is a classifier of outlier sequences in multiple alignments
# Copyright (C) 2011  Aleksandr Levchuk
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


set -e
set -u
source ./api/pipeline.sh


if [ $# != 1 ] && [ $# != 2 ]; then
  echo "Usage: $0 <sample-size>  [-s]" >&2
  echo "" >&2
  echo "  <sample-size>        how many alignments should be in 1 sample" >&2
  echo "" >&2
  echo "  -f                   force always runing, never skip any steps" >&2
  exit 1
fi

# Arguments
SAMPLE_SIZE=$1                              # sample size (mandatory)
set +u
[ "$2" == '-f' ] && export ALWAYS_RUN=true  # skip steps (optional)
[ -n "$2" ] && [ "$2" != '-f' ] && (echo "Invalid option $3"; exit 1)
set -u


EXPERIMENT_NAME=$(ls -1d ./trial-*/ | tail -1 | cut -d/ -f 2)
UPSTREAM_DIR="./$EXPERIMENT_NAME/010-run-guidance-data-out"

DATA_OUT="$EXPERIMENT_NAME/$0-data-out/sample-size$SAMPLE_SIZE"

rm -rf $DATA_OUT-new # Danger Zone
mkdir -p $DATA_OUT-new 2> /dev/null && true


function callback {
  #
  # Whole MSA scores
  #
  
  MSA_SCORE_FILES=`echo \
    $UPSTREAM_DIR/sample-size$SAMPLE_SIZE*-nogaps/*/MSA.MAFFT.Guidance_msa.scr |
    tr " " "\n"`
  
  # If these files exists then *'s will expand
  if [[ $MSA_SCORE_FILES =~ \* ]]; then
    echo "$0: ERROR: Could not find score files $MSA_SCORE_FILES" >&2
    echo "Did you run the tasks generated by 010-run-guidance?" >&2
    exit 1
  fi
  
  grep "MEAN_RES_PAIR_SCORE" $MSA_SCORE_FILES | while read line; do
  
    sample=$(expr "$line" : '.*\(sample-[^/]*-nogaps\)/[^/]*/.*') || (
      echo "ERROR: Could not parse out sample in \"$line\""; exit 1)
  
    msa=$(expr "$line" : '.*sample-.*-nogaps/\([^/]*\)/.*') || (
      echo "ERROR: Could not parse out msa in \"$line\""; exit 1)
  
    #score=$(expr "$line" : '.*MEAN_COL_SCORE \([^ ]*\).*') || (
    #  echo "ERROR: Could not parse out score in \"$line\""; exit 1)
    score=$(expr "$line" : '.*MEAN_RES_PAIR_SCORE \([^ ]*\).*') || (
      echo "ERROR: Could not parse out score in \"$line\""; exit 1)
  
    echo -e "$score\t$msa" >> $DATA_OUT-new/$sample-mafft-guidance-msa-scr
  
  done
  
  
  
  #
  # Per-sequence scores
  #
  
  SEQ_SCORE_FILES=`echo \
    $UPSTREAM_DIR/sample-size$SAMPLE_SIZE*-nogaps/*/MSA.MAFFT.Guidance_res_pair_seq.scr_with_Names |
    tr " " "\n"`
  
  # If these files exists then *'s will expand
  if [[ $SEQ_SCORE_FILES =~ \* ]]; then
    echo "$0: ERROR: Could not find score files $SEQ_SCORE_FILES" >&2
    echo "Did you run the tasks generated by 010-run-guidance?" >&2
    exit 1
  fi
  
  egrep -v "^#END$" $SEQ_SCORE_FILES | grep -v SEQUENCE_NAME | \
  while read line; do
  
    sample=$(expr "$line" : '.*\(sample-[^/]*-nogaps\)/[^/]*/.*') || (
      echo "ERROR: Could not parse out sample in \"$line\""; exit 1)
  
    msa=$(expr "$line" : '.*sample-.*-nogaps/\([^/]*\)/.*') || (
      echo "ERROR: Could not parse out msa in \"$line\""; exit 1)
  
    payload=$(expr "$line" : '.*_seq.scr_with_Names:\(.*\)$') || (
      echo "ERROR: Could not parse out sample in \"$line\""; exit 1)
  
    seq_name=$(echo "$payload" | awk '{print $1}' )
    score=$(echo "$payload" | awk '{print $2}' )
  
    echo -e "$score\t$seq_name\t$msa" >> \
      $DATA_OUT-new/$sample-mafft-guidance-seq-scr
  done
  
  # Sort all files by first column numeric
  for i in $DATA_OUT-new/*-mafft-guidance-*-scr; do
    sort -n $i > $i-new
    mv $i{-new,}
  done
  
  # Danger Zone
  rm -rf $DATA_OUT
  
  # Commit
  mv $DATA_OUT{-new,}
}

# Pick the latest done file
upstream_done_time_prefix=$(
  ls -t $UPSTREAM_DIR/sample-size$SAMPLE_SIZE-id*-list-tab-nogaps/*-done |
    head -n 1 | sed 's/-done$//'
)
done_time_prefix=$DATA_OUT
pipeline   $upstream_done_time_prefix   $done_time_prefix \
  "Extract all GUIDANCE per-msa and per-seq seq_res_pair scores" \
  callback


echo "$DATA_OUT"
(cd $DATA_OUT; wc -l *)
